# 作用域和闭包

**作用域**：存储变量，并且之后可以方便的找到这些变量的规则

## 编译原理

> 尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。

### 传统编译语言流程

- 分词/词法分析（Tokenizing/Lexing）

    string ---> 代码块（词法单元）

    分词：无状态的
    词法分析：有状态的

- 解析/语法分析（Parsing）

    词法单元流 ---> 抽象语法树 （Abstract Syntax Tree，AST）

- 代码生成

    AST ---> 可执行代码

## 对话

**引擎**：负责编译和执行过程
**编译器**：负责语法分析及代码生成
**作用域**：负责手机并维护由所有声明的标识符（变量）组成的一系列查询，确定当前执行的代码对这些标识符的访问权限

`var a = 2;`

> 1. **编译器**干活儿中... 分解成词法单元... 解析成树结构... 代码生成
> 2. **编译器**：小作，这里有a吗？
> 3. **作用域**：有，*转到 - 6 -*
> 4. **作用域**：没有
> 5. **编译器**：小作，在这儿声明个a
> 6. **编译器**为引擎生成运行时所需代码
> 7. **引擎**：小作，这里有a吗？
> 8. **作用域**：有，*转到 - 11 -*
> 9. **作用域**：没有
> 10. **引擎**继续查找该变量 LHS/RHS 嵌套作用域，层层向上询问
> 11. **引擎**找到变量，赋值
> 12. **引擎**没找到，🙋‍♂️抛出异常

- es5 非严格模式下，LHS查找未找到，全局作用域会创建一个具有该名称的变量
- ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的

## 词法作用域

- 词法作用域
- 动态作用域（bash，perl）

**“遮蔽效应”**：内部的标识符“遮蔽”了外部的标识符

- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定
- 词法作用域查找只会查找一级标识符

### 欺骗词法

> 欺骗词法作用域会导致性能 下降。

- eval

在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。

    - setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串
    - new Function(..) 

- with

    严格模式下被禁止

- 性能

    如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简 单的做法就是完全不做任何优化。

    --- GC 无法判断是否 回收
