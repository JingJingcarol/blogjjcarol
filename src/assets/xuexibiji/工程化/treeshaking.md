# Tree-Shaking

> 如果把代码打包比作制作蛋糕。传统的方式是把鸡蛋(带壳)全部丢进去搅拌，然后放入烤箱，最后把(没有用的)蛋壳全部挑选并剔除出去。而 treeshaking 则是一开始就把有用的蛋白蛋黄放入搅拌，最后直接作出蛋糕。

具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的

- ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。
- 分析程序流，判断哪些变量未被使用、引用，进而删除此代码。

Tree-shaking的本质是消除无用的js代码。无用代码消除在广泛存在于传统的编程语言编译器中，编译器可以判断出某些代码根本不影响输出，然后消除这些代码，这个称之为DCE（dead code elimination）。

Tree-shaking 和传统的 DCE的方法又不太一样，传统的DCE 消灭不可能执行的代码，而Tree-shaking 更关注于消除没有用到的代码。

Tree Shaking只支持ES Module(import....) 不支持require....

基于 ES6 的静态引用，tree shaking 通过扫描所有 ES6 的 export，找出被 import 的内容并添加到最终代码中。 webpack 的实现是把所有 import 标记为有使用/无使用两种，在后续压缩时进行区别处理。

## uglify 与 rollup

- uglify没有完善的程序流分析。它可以简单的判断变量后续是否被引用、修改，但是不能判断一个变量完整的修改过程，不知道它是否已经指向了外部变量，所以很多有可能会产生副作用的代码，都只能保守的不删除。
- rollup有程序流分析的功能，可以更好的判断代码是否真正会产生副作用。
- 打包工具库、组件库
  - webpack有多种导出模式，一般大家都会选择最具通用性的umd方式，但是webpack却没支持导出ES模块的模式。rollup支持导出ES模块的包。

    假如你把所有的资源文件通过webpack打包到一个bundle文件里的话，那这个库文件从此与Tree-shaking无缘。

    很多工程化项目的babel编译配置，为了提高编译速度，其实是会忽略掉node_modules内的文件的。所以为了保证这些同学的使用，我们还是应该要暴露出一份编译过的ES6 Module

  - rollup支持程序流分析，能更加正确的判断项目本身的代码是否有副作用。
- 如果对项目非常有把握，可以通过uglify的一些编译配置，如：pure_getters: true，删除一些强制认为不会产生副作用的代码。

## babel编译 + webpack打包

Babel能把ES6/ES7的代码转化成指定浏览器能支持的代码。正是由于它，我们前端开发者才能有今天这样美好的开发环境，能够不用考虑浏览器兼容性地、畅快淋漓地使用最新的JavaScript语言特性

它将类被封装成了一个IIFE(立即执行函数)，然后返回一个构造函数，采用Object.defineProperty这样的形式，因为ES6的一些语法是有其特定的语义的。比如：

- 类内部声明的方法，是不可枚举的，而通过原型链声明的方法是可以枚举的。
- for...of的循环是通过遍历器(Iterator)迭代的，循环数组时并非是i++，然后通过下标寻值。

函数的参数若是引用类型，对于它属性的操作，都是有可能会产生副作用的。因为首先它是引用类型，对它属性的任何修改其实都是改变了函数外部的数据。其次获取或修改它的属性，会触发getter或者setter，而getter、setter是不透明的，有可能会产生副作用。

所以先使用babel编译，再webpack打包，一些没有被使用的类是不会被shaking掉的，故需要先webpack打包再babel编译

但是，webpack打包对于未写入ES规范的语法是不支持的，所以需要先使用babel编译到ES7...

先webpack打包再babel编译需要使用webpack plugin，webpack和babel官方都没有这样的插件
