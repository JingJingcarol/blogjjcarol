# 内存泄漏

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

## js的内存管理

- 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存
- 内存使用：即读写内存，也就是使用变量、函数等
- 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存
  - 不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在， 当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。
  - 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。
  - 垃圾回收
    - 引用计数垃圾收集
    - 标记清除算法
      - 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。
      - 从根部出发将能触及到的对象的标记清除。
      - 那些还存在标记的变量被视为准备删除的变量。
      - 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。

## 内存泄漏的识别办法

### 浏览器

- 打开开发者工具，选择 Performance 面板
- 在顶部勾选 Memory
- 点击左上角的 record 按钮
- 在页面上进行各种操作，模拟用户的使用情况
- 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况

在memory选项卡中
我们看到一共有Heap snapshot（JS堆快照),Allocation instrumentation on timeline（JS堆分配时间线）,Allocation sampling三种堆快照类型

- Summary 总览视图：按构造函数分组。用于捕捉对象及其使用的内存。对于定位DOM内存泄露特别有用。
- Comparison 对比视图：对比两个快照。用于对比不同操作之后的堆快照，查看内存的释放及引用计数，来分析内存是否泄露及其原因。
- Containment 内容视图：查看堆内容。更适合查看对象结构，有助于分析对象的引用情况。适用于分析闭包以及深入分析对象。
- Statistics 统计视图：总览堆的统计信息。

### 命令行

命令行可以使用 Node 提供的process.memoryUsage方法。
process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节

- rss（resident set size）：所有内存占用，包括指令区和堆栈。
- heapTotal："堆"占用的内存，包括用到的和没用到的。
- heapUsed：用到的堆的部分。
- external： V8 引擎内部的 C++ 对象占用的内存。
判断内存泄漏，以heapUsed字段为准。

## 内存泄漏场景

- 全局变量
- 闭包
- 获取dom
- 定时器
- 回调
- 子元素引用
- 添加未移除